{
  "version": 3,
  "file": "virtual-chat.js",
  "sourceRoot": "",
  "sources": [
    "virtual-chat.js"
  ],
  "sourcesContent": [
    "/**\n * Virtual Chat Container Implementation\n * Provides virtual scrolling for chat messages to handle thousands of messages efficiently\n */\n\nclass VirtualChatContainer {\n    constructor(containerId, options = {}) {\n        this.containerId = containerId;\n        this.container = document.getElementById(containerId);\n        this.messages = [];\n        this.visibleMessages = [];\n        \n        // Configuration\n        this.config = {\n            itemHeight: options.itemHeight || 100, // Average message height\n            overscan: options.overscan || 5, // Extra items to render outside viewport\n            scrollThreshold: options.scrollThreshold || 50, // Auto-scroll threshold\n            maxMessages: options.maxMessages || 10000, // Maximum messages to keep in memory\n            ...options\n        };\n        \n        // State\n        this.scrollTop = 0;\n        this.containerHeight = 0;\n        this.totalHeight = 0;\n        this.startIndex = 0;\n        this.endIndex = 0;\n        this.isAutoScrollEnabled = true;\n        this.isScrolling = false;\n        this.scrollToBottomQueued = false;\n        \n        // Performance optimization\n        this.rafId = null;\n        this.resizeObserver = null;\n        this.heightCache = new Map();\n        this.measuredHeights = new Map();\n        \n        this.init();\n    }\n    \n    init() {\n        this.createVirtualContainer();\n        this.setupEventListeners();\n        this.setupResizeObserver();\n        this.updateVisibleRange();\n    }\n    \n    createVirtualContainer() {\n        // Clear existing content\n        this.container.innerHTML = '';\n        \n        // Create virtual scrolling structure\n        this.container.innerHTML = `\n            <div class=\"virtual-chat-wrapper\" style=\"height: 100%; overflow: auto; position: relative;\">\n                <div class=\"virtual-chat-spacer\" style=\"height: 0px; width: 100%;\"></div>\n                <div class=\"virtual-chat-content\" style=\"position: relative; transform: translateY(0px);\">\n                    <!-- Virtual messages will be rendered here -->\n                </div>\n                <div class=\"virtual-chat-bottom-spacer\" style=\"height: 0px; width: 100%;\"></div>\n            </div>\n            <div class=\"scroll-to-bottom-btn\" style=\"\n                position: absolute;\n                bottom: 20px;\n                right: 20px;\n                background: #3b82f6;\n                color: white;\n                border-radius: 50%;\n                width: 48px;\n                height: 48px;\n                display: none;\n                align-items: center;\n                justify-content: center;\n                cursor: pointer;\n                box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n                transition: all 0.2s ease;\n                z-index: 10;\n            \" title=\"Scroll to bottom\">\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                    <polyline points=\"6,9 12,15 18,9\"></polyline>\n                </svg>\n            </div>\n        `;\n        \n        // Get references\n        this.wrapper = this.container.querySelector('.virtual-chat-wrapper');\n        this.spacer = this.container.querySelector('.virtual-chat-spacer');\n        this.content = this.container.querySelector('.virtual-chat-content');\n        this.bottomSpacer = this.container.querySelector('.virtual-chat-bottom-spacer');\n        this.scrollButton = this.container.querySelector('.scroll-to-bottom-btn');\n        \n        // Update container height\n        this.containerHeight = this.wrapper.clientHeight;\n    }\n    \n    setupEventListeners() {\n        // Scroll event with throttling\n        this.wrapper.addEventListener('scroll', this.throttle(this.handleScroll.bind(this), 16));\n        \n        // Scroll to bottom button\n        this.scrollButton.addEventListener('click', () => {\n            this.scrollToBottom(true);\n        });\n        \n        // Wheel event for scroll detection\n        this.wrapper.addEventListener('wheel', (e) => {\n            if (e.deltaY < 0) {\n                // Scrolling up - disable auto-scroll\n                this.isAutoScrollEnabled = false;\n            }\n        });\n    }\n    \n    setupResizeObserver() {\n        if ('ResizeObserver' in window) {\n            this.resizeObserver = new ResizeObserver(entries => {\n                for (let entry of entries) {\n                    const newHeight = entry.contentRect.height;\n                    if (newHeight !== this.containerHeight) {\n                        this.containerHeight = newHeight;\n                        this.updateVisibleRange();\n                    }\n                }\n            });\n            this.resizeObserver.observe(this.wrapper);\n        }\n    }\n    \n    handleScroll() {\n        this.scrollTop = this.wrapper.scrollTop;\n        \n        // Check if user is near bottom\n        const isNearBottom = this.scrollTop + this.containerHeight >= this.totalHeight - this.config.scrollThreshold;\n        \n        if (isNearBottom) {\n            this.isAutoScrollEnabled = true;\n            this.scrollButton.style.display = 'none';\n        } else {\n            this.scrollButton.style.display = 'flex';\n        }\n        \n        // Update visible range\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n        this.rafId = requestAnimationFrame(() => {\n            this.updateVisibleRange();\n        });\n    }\n    \n    updateVisibleRange() {\n        if (this.messages.length === 0) {\n            this.renderMessages();\n            return;\n        }\n        \n        // Calculate visible range with overscan\n        const scrollTop = this.scrollTop;\n        const scrollBottom = scrollTop + this.containerHeight;\n        \n        // Find start index\n        let startIndex = 0;\n        let accumulatedHeight = 0;\n        \n        for (let i = 0; i < this.messages.length; i++) {\n            const messageHeight = this.getMessageHeight(i);\n            if (accumulatedHeight + messageHeight > scrollTop) {\n                startIndex = Math.max(0, i - this.config.overscan);\n                break;\n            }\n            accumulatedHeight += messageHeight;\n        }\n        \n        // Find end index\n        let endIndex = startIndex;\n        accumulatedHeight = this.getOffsetTop(startIndex);\n        \n        for (let i = startIndex; i < this.messages.length; i++) {\n            if (accumulatedHeight > scrollBottom) {\n                endIndex = Math.min(this.messages.length - 1, i + this.config.overscan);\n                break;\n            }\n            accumulatedHeight += this.getMessageHeight(i);\n            endIndex = i;\n        }\n        \n        // Update if range changed\n        if (startIndex !== this.startIndex || endIndex !== this.endIndex) {\n            this.startIndex = startIndex;\n            this.endIndex = endIndex;\n            this.renderMessages();\n        }\n    }\n    \n    getMessageHeight(index) {\n        const messageId = this.messages[index]?.id;\n        if (messageId && this.measuredHeights.has(messageId)) {\n            return this.measuredHeights.get(messageId);\n        }\n        return this.config.itemHeight;\n    }\n    \n    getOffsetTop(index) {\n        let offset = 0;\n        for (let i = 0; i < index; i++) {\n            offset += this.getMessageHeight(i);\n        }\n        return offset;\n    }\n    \n    measureMessage(element, messageId) {\n        if (element && messageId) {\n            const height = element.offsetHeight;\n            this.measuredHeights.set(messageId, height);\n            return height;\n        }\n        return this.config.itemHeight;\n    }\n    \n    renderMessages() {\n        if (!this.content) return;\n        \n        // Calculate total height\n        this.totalHeight = 0;\n        for (let i = 0; i < this.messages.length; i++) {\n            this.totalHeight += this.getMessageHeight(i);\n        }\n        \n        // Update spacers\n        const offsetTop = this.getOffsetTop(this.startIndex);\n        const offsetBottom = this.totalHeight - this.getOffsetTop(this.endIndex + 1);\n        \n        this.spacer.style.height = `${offsetTop}px`;\n        this.bottomSpacer.style.height = `${offsetBottom}px`;\n        \n        // Render visible messages\n        const fragment = document.createDocumentFragment();\n        \n        for (let i = this.startIndex; i <= this.endIndex; i++) {\n            if (i < this.messages.length) {\n                const messageEl = this.createMessageElement(this.messages[i], i);\n                fragment.appendChild(messageEl);\n            }\n        }\n        \n        this.content.innerHTML = '';\n        this.content.appendChild(fragment);\n        \n        // Measure rendered messages\n        this.content.querySelectorAll('.virtual-message').forEach((el, index) => {\n            const globalIndex = this.startIndex + index;\n            const message = this.messages[globalIndex];\n            if (message) {\n                this.measureMessage(el, message.id);\n            }\n        });\n        \n        // Handle queued scroll to bottom\n        if (this.scrollToBottomQueued) {\n            this.scrollToBottomQueued = false;\n            this.scrollToBottom(false);\n        }\n    }\n    \n    createMessageElement(message, index) {\n        const messageEl = document.createElement('div');\n        messageEl.className = `virtual-message chat-message ${message.type === 'user' ? 'user-message' : 'agent-message'}`;\n        messageEl.dataset.messageId = message.id;\n        messageEl.dataset.index = index;\n        \n        if (message.type === 'user') {\n            messageEl.innerHTML = this.renderUserMessage(message);\n        } else {\n            messageEl.innerHTML = this.renderAgentMessage(message);\n        }\n        \n        // Add animation class for new messages\n        if (message.isNew) {\n            messageEl.classList.add('animate-slide-in');\n            // Remove the flag and animation class after animation\n            setTimeout(() => {\n                message.isNew = false;\n                messageEl.classList.remove('animate-slide-in');\n            }, 300);\n        }\n        \n        return messageEl;\n    }\n    \n    renderUserMessage(message) {\n        return `\n            <div class=\"flex justify-end mb-4\">\n                <div class=\"max-w-[80%] px-4 py-2 bg-blue-600 text-white rounded-lg rounded-br-none text-sm\">\n                    ${this.escapeHtml(message.content)}\n                    ${message.timestamp ? `<div class=\"text-xs opacity-75 mt-1\">${new Date(message.timestamp).toLocaleTimeString()}</div>` : ''}\n                </div>\n            </div>\n        `;\n    }\n    \n    renderAgentMessage(message) {\n        return `\n            <div class=\"flex justify-start mb-4\">\n                <div class=\"max-w-[80%]\">\n                    <div class=\"flex items-center space-x-2 mb-2\">\n                        <div class=\"font-medium text-xs text-gray-600\">${this.escapeHtml(message.agentName || 'Assistant')}</div>\n                        ${message.enhanced ? '<span class=\"inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800\">Enhanced</span>' : ''}\n                        ${message.timestamp ? `<span class=\"text-xs text-gray-400\">${new Date(message.timestamp).toLocaleTimeString()}</span>` : ''}\n                    </div>\n                    <div class=\"px-6 py-4 bg-gray-100 text-gray-800 rounded-lg rounded-bl-none shadow-sm\">\n                        <div class=\"agent-response text-sm leading-relaxed\">\n                            ${this.formatAgentResponse(message.content)}\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n    }\n    \n    // Message management methods\n    addMessage(message) {\n        // Generate ID if not provided\n        if (!message.id) {\n            message.id = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        }\n        \n        // Add timestamp if not provided\n        if (!message.timestamp) {\n            message.timestamp = new Date().toISOString();\n        }\n        \n        // Mark as new for animation\n        message.isNew = true;\n        \n        // Add to messages array\n        this.messages.push(message);\n        \n        // Trim messages if exceeding limit\n        if (this.messages.length > this.config.maxMessages) {\n            const removed = this.messages.splice(0, this.messages.length - this.config.maxMessages);\n            // Clean up height cache for removed messages\n            removed.forEach(msg => {\n                this.measuredHeights.delete(msg.id);\n            });\n        }\n        \n        // Update visible range\n        this.updateVisibleRange();\n        \n        // Auto-scroll to bottom if enabled\n        if (this.isAutoScrollEnabled) {\n            // Queue scroll to bottom after render\n            this.scrollToBottomQueued = true;\n        }\n    }\n    \n    addMessages(messages) {\n        messages.forEach(message => {\n            this.addMessage(message);\n        });\n    }\n    \n    clearMessages() {\n        this.messages = [];\n        this.measuredHeights.clear();\n        this.startIndex = 0;\n        this.endIndex = 0;\n        this.totalHeight = 0;\n        this.isAutoScrollEnabled = true;\n        this.renderMessages();\n    }\n    \n    scrollToBottom(smooth = true) {\n        if (!this.wrapper) return;\n        \n        const scrollOptions = {\n            top: this.totalHeight,\n            behavior: smooth ? 'smooth' : 'auto'\n        };\n        \n        this.wrapper.scrollTo(scrollOptions);\n        this.isAutoScrollEnabled = true;\n        this.scrollButton.style.display = 'none';\n    }\n    \n    scrollToMessage(messageId) {\n        const messageIndex = this.messages.findIndex(msg => msg.id === messageId);\n        if (messageIndex === -1) return;\n        \n        const offsetTop = this.getOffsetTop(messageIndex);\n        this.wrapper.scrollTo({\n            top: offsetTop,\n            behavior: 'smooth'\n        });\n    }\n    \n    updateMessage(messageId, updates) {\n        const messageIndex = this.messages.findIndex(msg => msg.id === messageId);\n        if (messageIndex === -1) return;\n        \n        // Update message\n        Object.assign(this.messages[messageIndex], updates);\n        \n        // Clear height cache for this message\n        this.measuredHeights.delete(messageId);\n        \n        // Re-render if message is visible\n        if (messageIndex >= this.startIndex && messageIndex <= this.endIndex) {\n            this.renderMessages();\n        }\n    }\n    \n    removeMessage(messageId) {\n        const messageIndex = this.messages.findIndex(msg => msg.id === messageId);\n        if (messageIndex === -1) return;\n        \n        // Remove from messages array\n        this.messages.splice(messageIndex, 1);\n        \n        // Clean up height cache\n        this.measuredHeights.delete(messageId);\n        \n        // Update visible range\n        this.updateVisibleRange();\n    }\n    \n    // Utility methods\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n    \n    formatAgentResponse(text) {\n        // Reuse the existing formatAgentResponse function from the main interface\n        if (window.formatAgentResponse) {\n            return window.formatAgentResponse(text);\n        }\n        \n        // Fallback formatting\n        return this.escapeHtml(text).replace(/\\n/g, '<br>');\n    }\n    \n    throttle(func, limit) {\n        let inThrottle;\n        return function() {\n            const args = arguments;\n            const context = this;\n            if (!inThrottle) {\n                func.apply(context, args);\n                inThrottle = true;\n                setTimeout(() => inThrottle = false, limit);\n            }\n        }\n    }\n    \n    // Cleanup\n    destroy() {\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId);\n        }\n        \n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n        }\n        \n        // Remove event listeners\n        if (this.wrapper) {\n            this.wrapper.removeEventListener('scroll', this.handleScroll);\n            this.wrapper.removeEventListener('wheel', this.handleWheel);\n        }\n        \n        if (this.scrollButton) {\n            this.scrollButton.removeEventListener('click', this.scrollToBottom);\n        }\n        \n        // Clear references\n        this.messages = [];\n        this.measuredHeights.clear();\n        this.container = null;\n        this.wrapper = null;\n        this.content = null;\n    }\n    \n    // Public API methods\n    getMessageCount() {\n        return this.messages.length;\n    }\n    \n    getVisibleRange() {\n        return {\n            start: this.startIndex,\n            end: this.endIndex,\n            total: this.messages.length\n        };\n    }\n    \n    isAtBottom() {\n        return this.isAutoScrollEnabled && \n               this.scrollTop + this.containerHeight >= this.totalHeight - this.config.scrollThreshold;\n    }\n    \n    // Performance monitoring\n    getPerformanceStats() {\n        return {\n            totalMessages: this.messages.length,\n            visibleMessages: this.endIndex - this.startIndex + 1,\n            measuredHeights: this.measuredHeights.size,\n            totalHeight: this.totalHeight,\n            containerHeight: this.containerHeight,\n            memoryUsage: {\n                messages: this.messages.length * 200, // Rough estimate in bytes\n                heightCache: this.measuredHeights.size * 50\n            }\n        };\n    }\n}"
  ],
  "names": [],
  "mappings": "AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}