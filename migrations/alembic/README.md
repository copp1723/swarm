# Alembic Migration Guide for SWARM

This README explains **how we manage relational database schema changes** for the SWARM platform using **[Alembic](https://alembic.sqlalchemy.org/)**.  
These instructions assume you have:

* cloned the repository  
* created/activated a Python virtual-environment  
* installed requirements via `pip install -r mcp_new_project/config/requirements/requirements.txt`  

---

## 1. Why Alembic?

SWARM originally shipped raw `.sql` scripts. That approach breaks down once:

* multiple developers create migrations concurrently  
* we need to support **SQLite (local)** _and_ **PostgreSQL (production)**  
* rollbacks, zero-downtime deploys and CI verification become mandatory  

Alembic builds on SQLAlchemy‚Äôs metadata, providing:

* versioned migration scripts stored in `migrations/alembic/versions/`  
* automatic diffs (`--autogenerate`) plus manual editing for complex changes  
* safe upgrade / downgrade workflows  

---

## 2. Directory Layout

```
mcp_new_project/
‚îî‚îÄ migrations/
   ‚îî‚îÄ alembic/
      ‚îú‚îÄ alembic.ini         # global config (copied here for container builds)
      ‚îú‚îÄ env.py              # Alembic runtime environment
      ‚îú‚îÄ README.md           # ‚Üê you are here
      ‚îî‚îÄ versions/           # autogenerated migration scripts live here
```

> **Tip:** `env.py` loads `DATABASE_URL` from your `.env`, so there is no need to hard-code credentials.

---

## 3. Initialising the Database

Run once after setting `DATABASE_URL` in `.env` (or exporting it):

```bash
# Example: SQLite dev database
export DATABASE_URL="sqlite:///instance/mcp_executive.db"

# Create all tables & stamp the current schema as the base
alembic stamp head      # records current state without running migrations
```

For a **fresh Postgres** instance you can simply `alembic upgrade head` (see ¬ß4).

---

## 4. Common Migration Commands

| Task | Command | Notes |
|------|---------|-------|
| Generate new revision (autodetect changes) | `alembic revision --autogenerate -m "add user preferences"` | Edit the file before committing ‚Äì verify indices, defaults, etc. |
| Upgrade to latest version | `alembic upgrade head` | Applies all pending migrations |
| Downgrade one step | `alembic downgrade -1` | Always take a backup first in production |
| Downgrade to specific revision | `alembic downgrade <rev_id>` | Use the revision id prefix printed in logs |
| Show current DB revision | `alembic current` | |
| View revision history | `alembic history` | |
| Mark DB as up-to-date without running migration | `alembic stamp <rev_id>` | Dangerous ‚Äì use only for legacy databases |

All commands must be executed from `mcp_new_project/migrations/alembic/` _or_ anywhere in the repo if you pass `-c mcp_new_project/migrations/alembic/alembic.ini`.

---

## 5. Multi-Environment Configuration

`alembic.ini` ships with **SQLite** URL by default. `env.py` overrides it if `DATABASE_URL` is set, enabling simple environment switches:

```bash
# Local dev (SQLite)
export DATABASE_URL="sqlite:///instance/mcp_executive.db"

# Containerised Postgres
export DATABASE_URL="postgresql+psycopg2://swarm:swarm@db:5432/swarm_db"
```

`alembic upgrade head` then targets the chosen database.

---

## 6. Best Practices

1. **One logical change = one migration.** Avoid bundling unrelated tables in the same revision.  
2. **Review autogenerated diffs.** Alembic may miss server defaults or index names ‚Äì always open the new file.  
3. **Prefer forward migrations.** Downgrades are for emergencies only; write them but test upgrades first.  
4. **Keep migrations deterministic.** Don‚Äôt query live data; use pure DDL where possible.  
5. **CI enforcement.** Our GitHub workflow runs `alembic upgrade head && alembic downgrade -1 && alembic upgrade head` to catch irreversible migrations.  
6. **Backup before production downgrades.** Even ‚Äúsafe‚Äù downgrades can cause data loss.  
7. **No conflicts on main.** If two branches add migrations, rebase and regenerate to keep linear history.  

---

## 7. Workflow Example

```bash
# 1. Update SQLAlchemy models (e.g., add column 'timezone' to User)
vim mcp_new_project/models/user_models.py

# 2. Generate migration
alembic revision --autogenerate -m "add timezone to user"

# 3. Inspect & adjust the generated script in migrations/alembic/versions/<rev>_add_timezone_to_user.py

# 4. Run locally
alembic upgrade head

# 5. Run tests
pytest

# 6. Commit migration + model changes
git add .
git commit -m "feat(db): add timezone column to user"

# 7. Push branch & open PR
```

---

## 8. Integrating with Validation Script

After running migrations in any environment, execute the validation helper to ensure schema alignment with Drizzle definitions:

```bash
python scripts/validate-schema-alignment.ts   # Node/TS script compiled to JS or use ts-node
```

---

## 9. Troubleshooting

| Problem | Solution |
|---------|----------|
| `ModuleNotFoundError` for your app modules | Ensure project root is added to `PYTHONPATH` or run from repo root |
| ‚ÄúTarget database is not up to date‚Äù during deploy | Run `alembic upgrade head` in the release step |
| Revision conflict | Rebase, regenerate, or `alembic merge` (last resort) |
| `No such table` errors after model change | Did you forget to create a migration or run upgrades? |

---

## 10. Further Reading

* Alembic Documentation ‚Äì <https://alembic.sqlalchemy.org/en/latest/>  
* SQLAlchemy Migration Patterns ‚Äì <https://docs.sqlalchemy.org/en/20/changelog/migration.html>  
* Postgres Best Practices ‚Äì <https://wiki.postgresql.org/wiki/Best_Practices>  

---

Happy migrating! üíæ
