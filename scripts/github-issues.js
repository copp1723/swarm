#!/usr/bin/env node

const fs = require('fs')
const path = require('path')

// GitHub issue templates and helpers
class GitHubIssueManager {
  constructor() {
    this.issuesQueue = []
    this.screenshotsPath = path.join(process.cwd(), 'cypress', 'screenshots')
  }

  // Add issue to queue
  queueIssue(title, description, labels = ['bug'], screenshotPath = null) {
    const issue = {
      title,
      description,
      labels,
      screenshotPath,
      timestamp: new Date().toISOString(),
      browser: global.currentBrowser || 'unknown',
      viewport: global.currentViewport || 'unknown'
    }
    
    this.issuesQueue.push(issue)
    console.log(`📝 Queued GitHub issue: ${title}`)
  }

  // Generate issue body with context
  generateIssueBody(issue) {
    const body = `## Bug Report

**Browser:** ${issue.browser}
**Viewport:** ${issue.viewport}
**Timestamp:** ${issue.timestamp}

### Description
${issue.description}

### Environment
- **Testing Suite:** Cross-browser & Viewport QA
- **Test Runner:** Cypress
- **Generated by:** Automated Testing

### Steps to Reproduce
1. Open the MCP Agent Chat Interface
2. Set browser to ${issue.browser}
3. Set viewport to ${issue.viewport}
4. Perform the action that triggered this issue

### Expected Behavior
The feature should work correctly across all supported browsers and viewport sizes.

### Actual Behavior
${issue.description}

${issue.screenshotPath ? `### Screenshot\n![Screenshot](${issue.screenshotPath})\n` : ''}

### Additional Context
This issue was automatically detected during cross-browser QA testing. The following features were being tested:
- Sidebar toggle functionality
- Chat send functionality
- File upload stub
- Collaboration modal
- Keyboard shortcuts
- Responsive design integrity

### Priority
- [ ] High (Blocking functionality)
- [x] Medium (UI/UX issue)
- [ ] Low (Minor improvement)

### Browser Support
- [ ] Chrome
- [ ] Firefox  
- [ ] Safari/Webkit
- [ ] Edge

---
*This issue was automatically generated by the QA testing suite.*`

    return body
  }

  // Create GitHub issue using GitHub CLI (if available)
  async createIssueWithCLI(issue) {
    const { spawn } = require('child_process')
    
    return new Promise((resolve, reject) => {
      const body = this.generateIssueBody(issue)
      const labels = issue.labels.join(',')
      
      const ghArgs = [
        'issue', 'create',
        '--title', issue.title,
        '--body', body,
        '--label', labels
      ]
      
      console.log(`Creating GitHub issue: ${issue.title}`)
      
      const gh = spawn('gh', ghArgs, {
        stdio: 'pipe',
        cwd: process.cwd()
      })
      
      let output = ''
      let error = ''
      
      gh.stdout.on('data', (data) => {
        output += data.toString()
      })
      
      gh.stderr.on('data', (data) => {
        error += data.toString()
      })
      
      gh.on('close', (code) => {
        if (code === 0) {
          console.log(`✅ Created GitHub issue: ${issue.title}`)
          console.log(`   URL: ${output.trim()}`)
          resolve({ success: true, url: output.trim() })
        } else {
          console.error(`❌ Failed to create GitHub issue: ${issue.title}`)
          console.error(`   Error: ${error}`)
          reject(new Error(`GitHub CLI failed with code ${code}: ${error}`))
        }
      })
    })
  }

  // Create issues using GitHub API (requires token)
  async createIssueWithAPI(issue, token, repo) {
    const https = require('https')
    
    const body = this.generateIssueBody(issue)
    
    const data = JSON.stringify({
      title: issue.title,
      body: body,
      labels: issue.labels
    })
    
    const options = {
      hostname: 'api.github.com',
      port: 443,
      path: `/repos/${repo}/issues`,
      method: 'POST',
      headers: {
        'Authorization': `token ${token}`,
        'User-Agent': 'Cypress-QA-Suite',
        'Content-Type': 'application/json',
        'Content-Length': data.length
      }
    }
    
    return new Promise((resolve, reject) => {
      const req = https.request(options, (res) => {
        let responseData = ''
        
        res.on('data', (chunk) => {
          responseData += chunk
        })
        
        res.on('end', () => {
          if (res.statusCode === 201) {
            const issueData = JSON.parse(responseData)
            console.log(`✅ Created GitHub issue: ${issue.title}`)
            console.log(`   URL: ${issueData.html_url}`)
            resolve({ success: true, url: issueData.html_url, data: issueData })
          } else {
            console.error(`❌ Failed to create GitHub issue: ${issue.title}`)
            console.error(`   Status: ${res.statusCode}`)
            console.error(`   Response: ${responseData}`)
            reject(new Error(`GitHub API failed with status ${res.statusCode}`))
          }
        })
      })
      
      req.on('error', (error) => {
        reject(error)
      })
      
      req.write(data)
      req.end()
    })
  }

  // Process all queued issues
  async processQueue(method = 'cli', options = {}) {
    if (this.issuesQueue.length === 0) {
      console.log('📝 No GitHub issues to create')
      return []
    }
    
    console.log(`\n📝 Processing ${this.issuesQueue.length} GitHub issues...`)
    
    const results = []
    
    for (const issue of this.issuesQueue) {
      try {
        let result
        
        if (method === 'cli') {
          result = await this.createIssueWithCLI(issue)
        } else if (method === 'api') {
          if (!options.token || !options.repo) {
            throw new Error('GitHub token and repo required for API method')
          }
          result = await this.createIssueWithAPI(issue, options.token, options.repo)
        } else {
          // Dry run - just log what would be created
          console.log(`🔍 [DRY RUN] Would create issue: ${issue.title}`)
          result = { success: true, url: 'dry-run', dryRun: true }
        }
        
        results.push({ issue, result })
        
        // Add delay between requests to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 1000))
        
      } catch (error) {
        console.error(`❌ Failed to create issue "${issue.title}":`, error.message)
        results.push({ issue, error: error.message })
      }
    }
    
    // Clear the queue
    this.issuesQueue = []
    
    return results
  }

  // Save issues to file for manual creation
  saveIssuesToFile(filename = 'github-issues.json') {
    const filepath = path.join(process.cwd(), 'cypress', 'reports', filename)
    
    const issueData = {
      timestamp: new Date().toISOString(),
      issues: this.issuesQueue.map(issue => ({
        ...issue,
        body: this.generateIssueBody(issue)
      }))
    }
    
    // Ensure directory exists
    fs.mkdirSync(path.dirname(filepath), { recursive: true })
    fs.writeFileSync(filepath, JSON.stringify(issueData, null, 2))
    
    console.log(`📝 Saved ${this.issuesQueue.length} issues to ${filepath}`)
    return filepath
  }

  // Get list of available screenshots
  getAvailableScreenshots() {
    if (!fs.existsSync(this.screenshotsPath)) {
      return []
    }
    
    return fs.readdirSync(this.screenshotsPath)
      .filter(file => file.endsWith('.png'))
      .map(file => path.join(this.screenshotsPath, file))
  }

  // Generate summary report
  generateSummary() {
    const screenshots = this.getAvailableScreenshots()
    
    return {
      queuedIssues: this.issuesQueue.length,
      availableScreenshots: screenshots.length,
      screenshots: screenshots,
      issues: this.issuesQueue.map(issue => ({
        title: issue.title,
        browser: issue.browser,
        viewport: issue.viewport,
        labels: issue.labels
      }))
    }
  }
}

// Export for use in other scripts
module.exports = GitHubIssueManager

// CLI usage
if (require.main === module) {
  const manager = new GitHubIssueManager()
  
  // Example usage
  manager.queueIssue(
    'Sidebar toggle not working on mobile',
    'The mobile sidebar toggle button does not respond to clicks on Firefox mobile viewport',
    ['bug', 'mobile', 'firefox'],
    'sidebar-error-mobile.png'
  )
  
  // Process issues (dry run by default)
  manager.processQueue('dry-run').then(results => {
    console.log('\n📊 Issue Processing Summary:')
    console.log(`   Total issues: ${results.length}`)
    console.log(`   Successful: ${results.filter(r => r.result?.success).length}`)
    console.log(`   Failed: ${results.filter(r => r.error).length}`)
  })
}

